## Database and Model diagram
<img width="753" alt="image" src="https://github.com/user-attachments/assets/dbfb0384-e4b7-4bc3-81f3-f42f50e88d54">

## Design choices discussion

Description of some of the design choices I’ve encountered and why I’ve made them. I tried to stick to reasonable work time by simplifying when possible and cheap, but still made sure to detail how things could be changed or improved in further work.

1. I decided to merge `start_time` (datetime) and `duration` (int) into a `duration` range (tsrange) in Reservations table to simplify logic, improve query performance, and reduce room for bad data/erroneous states. As an API endpoint parameters they still exist per spec instructions. I also created a `timerange` Postgres range type.
2. Use restaurant row to represent one unique restaurant (with its own business hours, tables, etc’). The idea is to support several restaurants under one table reservation app. It also leaves an opening to later introduce a multi-tenant architecture, which will make the app much more powerful and cost effective to scale.
3. Instead of a restaurant’s own capacity field I decided that we can assume a restaurant’s capacity is measured by the capacity of the tables it has (so you can add/remove tables from a restaurant without also needing to update its capacity field each time), therefore reducing the possibility for bad or stale data.
4. Expressing the relationship between a `Table` and `Reservation`. Naive way is by adding `Table` a foreign key (`reservation_id` - “reservation has table/tables”). Problems: 1) Domain leak. Why does a table need to know what's a reservation? 2) Unnecessary writes into Table in reassigments, possible race conditions, and locks. 3) No records of previous tables associations with reservations 4) Query performance.  Some of these could be alleviated with another naive approach of having `tables_ids` array saved on a reservation, but not all. Solution: express the relationship through a “join table” (`reservation_tables`), which represents the association between a given reservation to its assigned tables.
5. The above also simplifies the logic of locking and releasing tables into a simple timestamp comparison query (vs more time intensive alternatives like: queue, mutex, tables pool etc’), with the disadvantage of being more strict (for example, not supporting "early release” of table if party finishes eating early in the restaurant). Even so, it makes it easier to add such functionality later if desired.
6. I implemented a naive first-come first-serve algorithm for the table assignment. It’s a greedy algorithm prioritizing reservations as they come and leaving as little unused capacity. Due to keeping with the time requirement I left it relatively simple, but given more time I would probably add a more involved implementation, like using simple combinatorics to support tables combinations (e.g. a party of 6 makes a reservation, but only a table of 2 and of 4 are available). The tradeoffs between different algorithms all revolve around resource intensity/performance vs maximizing capacity utilization of the tables. Another obvious thing to do would be to use a queue/background jobs + work with batches, instead of synchronously running the algorithm on every reservation creation, that way the algorithm is non-blocking.
